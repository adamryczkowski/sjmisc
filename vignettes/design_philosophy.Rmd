---
title: "The Design Philosophy of Functions in sjmisc"
author: "Daniel LÃ¼decke"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The Design Philosophy of Functions in sjmisc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The design of functions in this package follows, where appropriate, the _tidyverse-approach_, with the first argument of a function always being the data (either a data frame or vector), followed by variable names that should be processed by the function. If no variables are specified as argument, the function applies to the complete data that was indicated as first function argument.

## The data-argument

The major difference to dplyr-functions like `select()` or `filter()` is that the data-argument (the first argument of each function), may either be a _data frame_ or a _vector_. The returned object for each function _equals the type of the data-argument_:

  * If the data-argument is a vector, the function returns a vector.
  * If the data-argument is a data frame, the function returns a data frame.

```{r collapse=TRUE}
library(sjmisc)
data(efc)

# returns a vector
x <- rec(efc$e42dep, recodes = "1,2=1; 3,4=2")
str(x)

# returns a data frame (a tibble, to be exactly)
rec(efc, e42dep, recodes = "1,2=1; 3,4=2")
```

This small "inconsistency" has some advantages: You can use these functions both within a pipe-worklflow to manipulate data frames, or to create new variables, for instance with `mutate()`:

```{r collapse=TRUE, echo=FALSE, message=FALSE}
library(dplyr)
```
```{r collapse=TRUE}
efc %>% 
  select(c82cop1, c83cop2) %>% 
  rec(recodes = "1,2=0; 3:4=2")

efc %>% 
  select(c82cop1, c83cop2) %>% 
  mutate(
    c82cop1_dicho = rec(c82cop1, recodes = "1,2=0; 3:4=2"),
    c83cop2_dicho = rec(c83cop2, recodes = "1,2=0; 3:4=2")
  ) %>% 
  head()
```

## The function-types

There are two types of function designs:

### transformation/recoding functions

Functions like `rec()` or `dicho()`, that transform or recode variables, typically do _not_ return the complete data frame that was given as first argument, but only the transformed and recoded variables specified in the `...`-ellipses argument. The variables usually get a suffix, so you can bind these variables as new columns to a data frame.

```{r collapse=TRUE}
rec(efc, c82cop1, c83cop2, recodes = "1,2=0; 3:4=2")
```

### coercing/converting functions

Functions like `to_factor()` or `add_labels()`, convert variables into other types or add additional information like variable or value labels as attribute, typically return the complete data frame that was given as first argument. The variables specified in the `...`-ellipses argument are converted, all remaining variables remain unchanged.

```{r collapse=TRUE}
to_factor(efc, e42dep, e16sex)
```
