---
title: "Introduction into the sjmisc-Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction into the sjmisc-Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction into Labelled Data

_Labelled data_ (or labelled vectors) is a common data structure in other statistical environments to store meta-information about variables, like variable names, value labels or multiple defined missing values.

There are several approaches to facilitate this data structure in **R**, for instance packages like `haven`, `foreign`, `Hmisc`, or `labelled`. However, all these packages differ in the way how a labelled data structure is implemented, hence being capable to deal only with specific structures or classes of labelled vectors. The **sjmisc**-package aims at providing generic methods to work with any kind of labelled data.

_Labelled data_ not only extends **R**'s capabilities to deal with proper value _and_ variable labels, but also facilitates the representation of different types of missing values. Missing values no longer need to be represented by just a single value, `NA`, but each value can get a _missing flag_ via the `is_na`-attribute.

The **sjmisc**-package supports working with _labelled data_ and offers functions to benefit from these features.

## Labelled Data in haven and labelled

The `labelled`-package is intended to support `labelled` metadata structures only, thus the data structure of labelled vectors in `haven` and `labelled` is the same.

Labelled data in this format stores information about value labels, variable names and multiple defined missing values. However, _variable names_ are only part of this information if data was imported with one of `haven`s read-functions. Adding a variable label attribute is (at least currently) not possible via the `labelled`-constructor method.

```{r collapse=TRUE}
library(haven)
x <- labelled(c(1, 2, 1, 8, 9),
              c(Male = 1, Female = 2, 
                Refused = 8, "Not applicable" = 9),
              c(FALSE, FALSE, TRUE, TRUE))

print(x)
```

A `labelled` vector can either be a numeric or character vector. Conversion to factors copies the value labels as factor levels, but drops the variable label and `is_na` attributes.

## Labelled Data in Hmisc

The `Hmisc`-package only supports variable labels. As additional information, it can also store a unit measure.

```{r message=FALSE, collapse=TRUE}
library(Hmisc)
x <- c(1, 2, 3, 4)
label(x) <- "Variable label"
units(x) <- "cm"
str(x)
```

## Labelled Data in foreign

The `foreign`-package stores value labels as `value.labels` attribute, while variable labels are stored as attribute of the data frame returned by the `read.spss`-method. If you use `sjmisc::read_spss`, variable labels are added as attribute to each variable.

```{r eval=FALSE, collapse=TRUE}
library(foreign)
efc <- read.spss("sample_dataset.sav", 
                 to.data.frame = TRUE, 
                 use.value.labels = FALSE, 
                 reencode = "UTF-8")
str(efc$16sex)

> $e16sex  : atomic  2 2 2 2 2 2 1 2 2 2 ...
>  ..- attr(*, "value.labels")= Named chr  "2" "1"
>  .. ..- attr(*, "names")= chr  "female" "male"

attr(efc, "variable.labels")['e16sex']

>            e16sex 
>  "elder's gender" 
```

## Labelled Data in sjmisc

The **sjmisc**-package supports both label attributes in `haven`-style (`label` and `labels`) and `foreign`-style (`value.labels` and `variable.label`). Unlike `haven`, you can also have `factor`s with label and `is_na` attributes; you're not restricted to the `labelled` class for vectors when working with **sjmisc** and labelled data.

```{r message=FALSE, collapse=TRUE}
library(sjmisc)
# sjmisc-sample data
data(efc)
str(efc$e16sex)
```

# Value Labels

## Getting value labels

The `get_labels()`-method returns value labels of a vector or data frame.
```{r collapse=TRUE}
get_labels(efc$e42dep)
```

You can prefix the value labels with the associated values or return them as named vector with the `include.values` argument.
```{r collapse=TRUE}
get_labels(efc$e42dep, include.values = "p")
```

`get_labels()` also returns "labels" of factors, even if the factor has no label attributes.
```{r collapse=TRUE}
x <- factor(c("low", "mid", "low", "hi", "mid", "low"))
get_labels(x)
```

To ensure that labels are only returned for vectors with label-attribute, use the `attr.only` argument.
```{r collapse=TRUE}
x <- factor(c("low", "mid", "low", "hi", "mid", "low"))
get_labels(x, attr.only = TRUE)
```

If a vector has a label attribute, only these labels are returned...
```{r collapse=TRUE}
x <- labelled(c(1, 2, 1, 3, 4, 1, NA, 5),
              c(Male = 1, Female = 2, Refused = 5),
              c(FALSE, FALSE, TRUE))
get_labels(x)
```

... however, you can add non-labelled values to the return value as well, using the `include.non.labelled` argument.
```{r collapse=TRUE}
get_labels(x, include.non.labelled = TRUE)
```

## Getting labelled values

The `get_values()` method returns the values for labelled values (i.e. values that have an associated label). We still use the vector `x` from the above examples.
```{r collapse=TRUE}
print(x)
get_values(x)
```

With the `drop.na` argument you can omit those values from the return values that are defined as missing.
```{r collapse=TRUE}
get_values(x, drop.na = TRUE)
```

## Setting value labels

With `set_labels()` you can add label attributes to any vector.
```{r collapse=TRUE}
x <- sample(1:4, 20, replace = TRUE)
x <- set_labels(x, c("very low", "low", "mid", "hi"))
x
```

If more labels than values are given, only as many labels elements are used as values are present.
```{r collapse=TRUE}
x <- c(2, 2, 3, 3, 2)
x <- set_labels(x, c("a", "b", "c"))
x
```

However, you can force to use all labels, even for values that are not in the vector, using the `force.labels` argument.
```{r collapse=TRUE}
x <- c(2, 2, 3, 3, 2)
x <- set_labels(x, c("a", "b", "c"), 
                force.labels = TRUE)
x
```

For vectors with more unique values than labels, additional labels for non-labelled values are added.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, NA)
x <- set_labels(x, c("yes", "maybe", "no"))
x
```

Use `force.values` to add only those labels that have been passed as argument.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, NA)
x <- set_labels(x, c("yes", "maybe", "no"),
                force.values = FALSE)
x
```

To add explicit labels for values (without adding more labels than wanted and without dropping labels for values that do not appear in the vector), use a named vector of labels as argument. The arguments `force.values` and `force.labels` are ignored when using named vectors.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, 5)
x <- set_labels(x, c(`1` = "strongly agree", 
                     `4` = "totally disagree", 
                     `5` = "refused",
                     `9` = "missing"))
x
```

# Variable Labels

# Missing Values

# Converting Vectors