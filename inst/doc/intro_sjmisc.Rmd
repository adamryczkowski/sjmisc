---
title: "Introduction into the sjmisc-Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction into the sjmisc-Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction into Labelled Data

_Labelled data_ (or labelled vectors) is a common data structure in other statistical environments to store meta-information about variables, like variable names, value labels or multiple defined missing values.

There are several approaches to facilitate this data structure in **R**, for instance packages like `haven`, `foreign`, `Hmisc`, or `labelled`. However, all these packages differ in the way how a labelled data structure is implemented, hence being capable to deal only with specific structures or classes of labelled vectors. The **sjmisc**-package aims at providing generic methods to work with any kind of labelled data.

_Labelled data_ not only extends **R**'s capabilities to deal with proper value _and_ variable labels, but also facilitates the representation of different types of missing values. Missing values no longer need to be represented by just a single value, `NA`, but each value can get a _missing flag_ via the `is_na`-attribute.

The **sjmisc**-package supports working with _labelled data_ and offers functions to benefit from these features.

## Labelled Data in haven and labelled

The `labelled`-package is intended to support `labelled` metadata structures only, thus the data structure of labelled vectors in `haven` and `labelled` is the same.

Labelled data in this format stores information about value labels, variable names and multiple defined missing values. However, _variable names_ are only part of this information if data was imported with one of `haven`s read-functions. Adding a variable label attribute is (at least currently) not possible via the `labelled`-constructor method.

```{r collapse=TRUE}
library(haven)
x <- labelled(c(1, 2, 1, 8, 9),
              c(Male = 1, Female = 2, 
                Refused = 8, "Not applicable" = 9),
              c(FALSE, FALSE, TRUE, TRUE))

print(x)
```

A `labelled` vector can either be a numeric or character vector. Conversion to factors copies the value labels as factor levels, but drops the variable label and `is_na` attributes.

## Labelled Data in Hmisc

The `Hmisc`-package only supports variable labels. As additional information, it can also store a unit measure.

```{r message=FALSE, collapse=TRUE}
library(Hmisc)
x <- c(1, 2, 3, 4)
label(x) <- "Variable label"
units(x) <- "cm"
str(x)
```

## Labelled Data in foreign

The `foreign`-package stores value labels as `value.labels` attribute, while variable labels are stored as attribute of the data frame returned by the `read.spss`-method. If you use `sjmisc::read_spss`, variable labels are added as attribute to each variable.

```{r eval=FALSE, collapse=TRUE}
library(foreign)
efc <- read.spss("sample_dataset.sav", 
                 to.data.frame = TRUE, 
                 use.value.labels = FALSE, 
                 reencode = "UTF-8")
str(efc$16sex)

> $e16sex  : atomic  2 2 2 2 2 2 1 2 2 2 ...
>  ..- attr(*, "value.labels")= Named chr  "2" "1"
>  .. ..- attr(*, "names")= chr  "female" "male"

attr(efc, "variable.labels")['e16sex']

>            e16sex 
>  "elder's gender" 
```

## Labelled Data in sjmisc

The **sjmisc**-package supports both label attributes in `haven`-style (`label` and `labels`) and `foreign`-style (`value.labels` and `variable.label`). Unlike `haven`, you can also have `factor`s with label and `is_na` attributes; you're not restricted to the `labelled` class for vectors when working with **sjmisc** and labelled data.

```{r message=FALSE, collapse=TRUE}
library(sjmisc)
# sjmisc-sample data
data(efc)
str(efc$e16sex)
```

# Value Labels

## Getting value labels

The `get_labels()`-method returns value labels of a vector or data frame.
```{r collapse=TRUE}
get_labels(efc$e42dep)
```

You can prefix the value labels with the associated values or return them as named vector with the `include.values` argument.
```{r collapse=TRUE}
get_labels(efc$e42dep, include.values = "p")
```

`get_labels()` also returns "labels" of factors, even if the factor has no label attributes.
```{r collapse=TRUE}
x <- factor(c("low", "mid", "low", "hi", "mid", "low"))
get_labels(x)
```

To ensure that labels are only returned for vectors with label-attribute, use the `attr.only` argument.
```{r collapse=TRUE}
x <- factor(c("low", "mid", "low", "hi", "mid", "low"))
get_labels(x, attr.only = TRUE)
```

If a vector has a label attribute, only these labels are returned...
```{r collapse=TRUE}
x <- labelled(c(1, 2, 1, 3, 4, 1, NA, 5),
              c(Male = 1, Female = 2, Refused = 5),
              c(FALSE, FALSE, TRUE))
get_labels(x)
```

... however, you can add non-labelled values to the return value as well, using the `include.non.labelled` argument.
```{r collapse=TRUE}
get_labels(x, include.non.labelled = TRUE)
```

## Getting labelled values

The `get_values()` method returns the values for labelled values (i.e. values that have an associated label). We still use the vector `x` from the above examples.
```{r collapse=TRUE}
print(x)
get_values(x)
```

With the `drop.na` argument you can omit those values from the return values that are defined as missing.
```{r collapse=TRUE}
get_values(x, drop.na = TRUE)
```

## Setting value labels

With `set_labels()` you can add label attributes to any vector.
```{r collapse=TRUE}
x <- sample(1:4, 20, replace = TRUE)
x <- set_labels(x, c("very low", "low", "mid", "hi"))
x
```

If more labels than values are given, only as many labels elements are used as values are present.
```{r collapse=TRUE}
x <- c(2, 2, 3, 3, 2)
x <- set_labels(x, c("a", "b", "c"))
x
```

However, you can force to use all labels, even for values that are not in the vector, using the `force.labels` argument.
```{r collapse=TRUE}
x <- c(2, 2, 3, 3, 2)
x <- set_labels(x, c("a", "b", "c"), 
                force.labels = TRUE)
x
```

For vectors with more unique values than labels, additional labels for non-labelled values are added.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, NA)
x <- set_labels(x, c("yes", "maybe", "no"))
x
```

Use `force.values` to add only those labels that have been passed as argument.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, NA)
x <- set_labels(x, c("yes", "maybe", "no"),
                force.values = FALSE)
x
```

To add explicit labels for values (without adding more labels than wanted and without dropping labels for values that do not appear in the vector), use a named vector of labels as argument. The arguments `force.values` and `force.labels` are ignored when using named vectors.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, 5)
x <- set_labels(x, c(`1` = "strongly agree", 
                     `4` = "totally disagree", 
                     `5` = "refused",
                     `9` = "missing"))
x
```

# Variable Labels

## Getting variable labels

The `get_label()`-method returns the variable label of a vector or all variable labels from a data frame.
```{r collapse=TRUE}
get_label(efc$e42dep)
```

Beside a single vector or a data frame, `get_label` also returns all variable labels of a list of vectors.

```{r collapse=TRUE}
get_label(list(efc$e42dep,
               efc$e16sex,
               efc$e15relat))
```

## Setting variable labels

The `set_label` function adds the variable label attribute to a vector.
```{r collapse=TRUE}
x <- sample(1:4, 10, replace = TRUE)
x <- set_label(x, "Dummy-variable")
str(x)
```

`set_label` can also set variable labels for a data frame. In this case, the variable attributes get an additional `name` attribute with the vector's name. This makes it easier to see which label belongs to which vector.
```{r collapse=TRUE}
x <- data.frame(a = sample(1:4, 10, replace = TRUE),
                b = sample(1:4, 10, replace = TRUE),
                c = sample(1:4, 10, replace = TRUE))
x <- set_label(x,
               c("Variable A",
                 "Variable B",
                 "Variable C"))

str(x)

get_label(x)
```                     
                     
# Missing Values

## Defining missing values

`set_na` converts values of a vector or of multiple vectors in a data frame into `NA`.
```{r collapse=TRUE}
x <- sample(1:8, 100, replace = TRUE)
# show value distribution
table(x)

# set value 1 and 8 as missings
x <- set_na(x, c(1, 8))
# show value distribution, including missings
table(x, exclude = NULL)

x <- factor(c("a", "b", "c"))
x

set_na(x, "b")
```

Supporting the new `is_na` attribute of labelled data, `set_na` also allows defining multiple missing value codes via the `as.attr` argument.
```{r collapse=TRUE}
x <- sample(1:5, 20, replace = TRUE)
x <- set_na(x, c(3, 5), as.attr = TRUE)
x
```

`set_na` automatically removes value label attributes of those values that have been set to `NA`.
```{r collapse=TRUE}
str(efc$c87cop6)

efc$c87cop6 <- set_na(efc$c87cop6, 3)
str(efc$c87cop6)

get_labels(efc$c87cop6)
```


## Getting missing values

The `get_na` function returns those values which are "flagged" as missing by the `is_na` attribute.
```{r collapse=TRUE}
get_na(x)
```

`get_na_flags` returns a logical vector of which values are coded as missing or not. It simply returns the `is_na` attribute of labelled data.
```{r collapse=TRUE}
x <- sample(1:5, 20, replace = TRUE)
x <- set_na(x, c(3, 5), as.attr = TRUE)

get_na_flags(x)
```

## Converting missing values into NA

`to_na` converts all values flagged as missing by `is_na`
```{r collapse=TRUE}
get_na(x)

to_na(x)
```

# Converting Labelled Vectors

## Converting labelled numeric into factor

`to_label` converts numeric labelled vectors into a factor and set the former labels as factor levels.
```{r collapse=TRUE}
head(to_label(efc$c87cop6))
```

By default, `to_label` converts all values into `NA` that are defined as missing via the `is_na` attribute. Use `drop.na` to change this behaviour.
```{r collapse=TRUE}
efc$c82cop1 <- set_na(efc$c82cop1, 3, as.attr = TRUE)

str(efc$c82cop1)

table(efc$c82cop1)

head(to_label(efc$c82cop1))

table(to_label(efc$c82cop1))

head(to_label(efc$c82cop1, drop.na = FALSE))

table(to_label(efc$c82cop1, drop.na = FALSE))
```

`to_label` only converts those values into factor levels, which have associated value labels. All other values are converted to `NA`. However, with the `add.non.labelled` argument additional factor levels for non-labelled values are created.
```{r collapse=TRUE}
x <- c(1, 2, 3, 2, 4, NA)
x <- set_labels(x, c(`1` = "always",
                     `4` = "never"))
str(x)

to_label(x)

to_label(x, add.non.labelled = T)
```

## Converting labelled numeric into numeric factor

`to_factor` converts any numeric labelled vector into a factor with numeric levels, however, value and variable lables are preserved as attribute.